1、转换用户指定的beanName、去除工厂引用前缀&并且获取到bean的最总名字
AbstractBeanFactory.transformedBeanName(String name);
	->BeanFactoryUtils.transformedBeanName(String name);从缓存transformedBeanNameCache中获取beanName，transformedBeanNameCache：工厂间接引用和beanName的映射
	->SimpleAliasRegistry.canonicalName(String name);循环从aliasMap中获取canonicalName对应的aliasName，直到没有对应的值，即为最终的beanName
2、从单例对象缓存中获取单例对象sharedInstance
DefaultSingletonBeanRegistry.getSingleton(String beanName);
	->DefaultSingletonBeanRegistry.getSingleton(String beanName, boolean allowEarlyReference)
	先从Map<String, Object> singletonObjects中获取对应beanName的单例对象singletonObject
	如果单例对象singletonObject为null且通过boolean isSingletonCurrentlyInCreation(String beanName)判断当前beanName包含在Set<String> singletonsCurrentlyInCreation中
	则从Map<String, Object> earlySingletonObjects中获取beanName对应的早期单例对象
	如果早期单例对象为null且允许使用早期依赖(即allowEarlyReference为true)
	则从Map<String, ObjectFactory<?>> singletonFactories中获取beanName对应的ObjectFactory singletonFactory(bean创建的策略化接口)
	如果singletonFactory不为null，则调用策略化接口ObjectFactory.getObject()方法获取单例对象
	然后在earlySingletonObjects中添加beanName和单例对象的映射并清除在singletonFactories中的对应beanName的ObjectFactory singletonFactory
3、如果sharedInstance不为null且args为null(单例对象的args都为null),调用Object AbstractBeanFactory.getObjectForBeanInstance(Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)方法
	如果用户指定的name为工厂引用(以&为前缀),如果beanInstance为NullBean类型，直接返回beanInstance,如果beanInstance不属于FactoryBean类型，抛出异常BeanIsNotAFactoryException
	经过上面的判断,如果用户指定name为工厂引用,则实例beanInstance一定为FactoryBean类型,反之实例beanInstance不是FactoryBean类型,则用户指定name一定不是工厂引用,此时直接返回实例beanInstance
	接下来是用户指定的name不是工厂引用且实例beanInstance是FactoryBean类型的情况,需要从FactoryBean类型的beanInstance中获取实例
	当参数mbd为null时通过FactoryBeanRegistrySupport.getCachedObjectForFactoryBean(String beanName)从Map<String, Object> factoryBeanObjectCache中获取beanName对应的实例
